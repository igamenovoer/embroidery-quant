<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Quantization App - RgbQuant.js</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .upload-section {
            border: 3px dashed #cbd5e0;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            background: #f7fafc;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-section:hover {
            border-color: #667eea;
            background: #edf2f7;
        }

        .upload-section.dragover {
            border-color: #667eea;
            background: #ebf8ff;
            transform: scale(1.02);
        }

        #fileInput {
            display: none;
        }

        .upload-text {
            font-size: 1.2em;
            color: #718096;
            margin-bottom: 15px;
        }

        .upload-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .upload-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #4a5568;
        }

        input, select {
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .process-button {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(72, 187, 120, 0.4);
            margin: 20px auto;
            display: block;
        }

        .process-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(72, 187, 120, 0.6);
        }

        .process-button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            box-shadow: none;
        }

        .images-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 15px;
            margin-top: 30px;
        }

        .image-section {
            text-align: center;
        }

        .image-section h3 {
            margin-bottom: 15px;
            color: #4a5568;
            font-size: 1.3em;
        }

        .image-wrapper {
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
            background: #f7fafc;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-wrapper img, .image-wrapper canvas {
            max-width: 100%;
            max-height: 400px;
            object-fit: contain;
        }

        .palette-section {
            margin-top: 30px;
            text-align: center;
        }

        .palette-section h3 {
            margin-bottom: 15px;
            color: #4a5568;
            font-size: 1.3em;
        }

        .palette-wrapper {
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            background: #f7fafc;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .download-section {
            text-align: center;
            margin-top: 20px;
        }

        .download-button {
            background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(237, 137, 54, 0.4);
            margin: 0 10px;
        }

        .download-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(237, 137, 54, 0.6);
        }

        .download-button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            box-shadow: none;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            font-weight: 600;
        }

        .status.success {
            background: #c6f6d5;
            color: #22543d;
            border: 2px solid #9ae6b4;
        }

        .status.error {
            background: #fed7d7;
            color: #742a2a;
            border: 2px solid #fc8181;
        }

        .status.processing {
            background: #bee3f8;
            color: #2c5282;
            border: 2px solid #90cdf4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¨ Image Quantization App</h1>
        
        <div class="upload-section" id="uploadSection">
            <div class="upload-text">Drag & drop an image here or click to select</div>
            <button class="upload-button" id="uploadButton">
                Choose Image
            </button>
            <input type="file" id="fileInput" accept="image/*">
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="sigmaSpace">Spatial Sigma (1-100):</label>
                <input type="number" id="sigmaSpace" min="1" max="100" value="15">
            </div>
            
            <div class="control-group">
                <label for="sigmaColor">Color Sigma (1-100):</label>
                <input type="number" id="sigmaColor" min="1" max="100" value="80">
            </div>
            
            <div class="control-group">
                <label for="colors">Number of Colors (2-256):</label>
                <input type="number" id="colors" min="2" max="256" value="16">
            </div>
            
            <div class="control-group">
                <label for="method">Quantization Method:</label>
                <select id="method">
                    <option value="1">Global Population</option>
                    <option value="2" selected>Subregion Population</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="dithKern">Dithering Algorithm:</label>
                <select id="dithKern">
                    <option value="">None</option>
                    <option value="FloydSteinberg">Floyd-Steinberg</option>
                    <option value="Atkinson">Atkinson</option>
                    <option value="Burkes">Burkes</option>
                    <option value="Stucki">Stucki</option>
                    <option value="Jarvis">Jarvis</option>
                    <option value="Sierra">Sierra</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="initColors">Initial Colors (256-8192):</label>
                <input type="number" id="initColors" min="256" max="8192" value="4096">
            </div>
        </div>

        <button class="process-button" id="processButton" disabled>
            Process Image
        </button>

        <div id="status"></div>

        <div class="images-container" id="imagesContainer" style="display: none;">
            <div class="image-section">
                <h3>Original Image</h3>
                <div class="image-wrapper">
                    <img id="originalImage" alt="Original Image">
                </div>
            </div>
            
            <div class="image-section">
                <h3>Bilateral Filtered</h3>
                <div class="image-wrapper">
                    <canvas id="filteredImage"></canvas>
                </div>
            </div>
            
            <div class="image-section">
                <h3>Quantized Original</h3>
                <div class="image-wrapper">
                    <canvas id="quantizedOriginal"></canvas>
                </div>
                <div class="download-section">
                    <button class="download-button" id="downloadOriginalPng" disabled>
                        Download PNG
                    </button>
                    <button class="download-button" id="downloadOriginalJpg" disabled>
                        Download JPG
                    </button>
                </div>
            </div>
            
            <div class="image-section">
                <h3>Quantized Filtered</h3>
                <div class="image-wrapper">
                    <canvas id="quantizedFiltered"></canvas>
                </div>
                <div class="download-section">
                    <button class="download-button" id="downloadFilteredPng" disabled>
                        Download PNG
                    </button>
                    <button class="download-button" id="downloadFilteredJpg" disabled>
                        Download JPG
                    </button>
                </div>
            </div>
        </div>

        <div class="palette-section" id="paletteSection" style="display: none;">
            <h3>Color Palette</h3>
            <div class="palette-wrapper">
                <canvas id="paletteCanvas"></canvas>
            </div>
        </div>
    </div>

    <!-- RgbQuant.js Library -->
    <script>
        /*
         * Copyright (c) 2015, Leon Sorokin
         * All rights reserved. (MIT Licensed)
         *
         * RgbQuant.js - an image quantization lib
         */
        
        (function(){
            function RgbQuant(opts) {
                opts = opts || {};

                // 1 = by global population, 2 = subregion population threshold
                this.method = opts.method || 2;
                // desired final palette size
                this.colors = opts.colors || 256;
                // # of highest-frequency colors to start with for palette reduction
                this.initColors = opts.initColors || 4096;
                // color-distance threshold for initial reduction pass
                this.initDist = opts.initDist || 0.01;
                // subsequent passes threshold
                this.distIncr = opts.distIncr || 0.005;
                // palette grouping
                this.hueGroups = opts.hueGroups || 10;
                this.satGroups = opts.satGroups || 10;
                this.lumGroups = opts.lumGroups || 10;
                // if > 0, enables hues stats and min-color retention per group
                this.minHueCols = opts.minHueCols || 0;
                // HueStats instance
                this.hueStats = this.minHueCols ? new HueStats(this.hueGroups, this.minHueCols) : null;

                // subregion partitioning box size
                this.boxSize = opts.boxSize || [64,64];
                // number of same pixels required within box for histogram inclusion
                this.boxPxls = opts.boxPxls || 2;
                // palette locked indicator
                this.palLocked = false;

                // dithering/error diffusion kernel name
                this.dithKern = opts.dithKern || null;
                // dither serpentine pattern
                this.dithSerp = opts.dithSerp || false;
                // minimum color difference (0-1) needed to dither
                this.dithDelta = opts.dithDelta || 0;

                // accumulated histogram
                this.histogram = {};
                // palette - rgb triplets
                this.idxrgb = opts.palette ? opts.palette.slice(0) : [];
                // palette - int32 vals
                this.idxi32 = [];
                // reverse lookup {i32:idx}
                this.i32idx = {};
                // {i32:rgb}
                this.i32rgb = {};
                // enable color caching (also incurs overhead of cache misses and cache building)
                this.useCache = opts.useCache !== false;
                // min color occurance count needed to qualify for caching
                this.cacheFreq = opts.cacheFreq || 10;
                // allows pre-defined palettes to be re-indexed (enabling palette compacting and sorting)
                this.reIndex = opts.reIndex || this.idxrgb.length == 0;
                // selection of color-distance equation
                this.colorDist = opts.colorDist == "manhattan" ? distManhattan : distEuclidean;

                // if pre-defined palette, build lookups
                if (this.idxrgb.length > 0) {
                    var self = this;
                    this.idxrgb.forEach(function(rgb, i) {
                        var i32 = (
                            (255    << 24) |	// alpha
                            (rgb[2] << 16) |	// blue
                            (rgb[1] <<  8) |	// green
                             rgb[0]				// red
                        ) >>> 0;

                        self.idxi32[i]		= i32;
                        self.i32idx[i32]	= i;
                        self.i32rgb[i32]	= rgb;
                    });
                }
            }

            // gathers histogram info
            RgbQuant.prototype.sample = function sample(img, width) {
                if (this.palLocked)
                    throw "Cannot sample additional images, palette already assembled.";

                var data = getImageData(img, width);

                switch (this.method) {
                    case 1: this.colorStats1D(data.buf32); break;
                    case 2: this.colorStats2D(data.buf32, data.width); break;
                }
            };

            // image quantizer
            RgbQuant.prototype.reduce = function reduce(img, retType, dithKern, dithSerp) {
                if (!this.palLocked)
                    this.buildPal();

                dithKern = dithKern || this.dithKern;
                dithSerp = typeof dithSerp != "undefined" ? dithSerp : this.dithSerp;

                retType = retType || 1;

                // reduce w/dither
                if (dithKern)
                    var out32 = this.dither(img, dithKern, dithSerp);
                else {
                    var data = getImageData(img),
                        buf32 = data.buf32,
                        len = buf32.length,
                        out32 = new Uint32Array(len);

                    for (var i = 0; i < len; i++) {
                        var i32 = buf32[i];
                        out32[i] = this.nearestColor(i32);
                    }
                }

                if (retType == 1)
                    return new Uint8Array(out32.buffer);

                if (retType == 2) {
                    var out = [],
                        len = out32.length;

                    for (var i = 0; i < len; i++) {
                        var i32 = out32[i];
                        out[i] = this.i32idx[i32];
                    }

                    return out;
                }
            };

            // adapted from http://jsbin.com/iXofIji/2/edit by PAEz
            RgbQuant.prototype.dither = function(img, kernel, serpentine) {
                // http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/
                var kernels = {
                    FloydSteinberg: [
                        [7 / 16, 1, 0],
                        [3 / 16, -1, 1],
                        [5 / 16, 0, 1],
                        [1 / 16, 1, 1]
                    ],
                    FalseFloydSteinberg: [
                        [3 / 8, 1, 0],
                        [3 / 8, 0, 1],
                        [2 / 8, 1, 1]
                    ],
                    Stucki: [
                        [8 / 42, 1, 0],
                        [4 / 42, 2, 0],
                        [2 / 42, -2, 1],
                        [4 / 42, -1, 1],
                        [8 / 42, 0, 1],
                        [4 / 42, 1, 1],
                        [2 / 42, 2, 1],
                        [1 / 42, -2, 2],
                        [2 / 42, -1, 2],
                        [4 / 42, 0, 2],
                        [2 / 42, 1, 2],
                        [1 / 42, 2, 2]
                    ],
                    Atkinson: [
                        [1 / 8, 1, 0],
                        [1 / 8, 2, 0],
                        [1 / 8, -1, 1],
                        [1 / 8, 0, 1],
                        [1 / 8, 1, 1],
                        [1 / 8, 0, 2]
                    ],
                    Jarvis: [			// Jarvis, Judice, and Ninke / JJN?
                        [7 / 48, 1, 0],
                        [5 / 48, 2, 0],
                        [3 / 48, -2, 1],
                        [5 / 48, -1, 1],
                        [7 / 48, 0, 1],
                        [5 / 48, 1, 1],
                        [3 / 48, 2, 1],
                        [1 / 48, -2, 2],
                        [3 / 48, -1, 2],
                        [5 / 48, 0, 2],
                        [3 / 48, 1, 2],
                        [1 / 48, 2, 2]
                    ],
                    Burkes: [
                        [8 / 32, 1, 0],
                        [4 / 32, 2, 0],
                        [2 / 32, -2, 1],
                        [4 / 32, -1, 1],
                        [8 / 32, 0, 1],
                        [4 / 32, 1, 1],
                        [2 / 32, 2, 1],
                    ],
                    Sierra: [
                        [5 / 32, 1, 0],
                        [3 / 32, 2, 0],
                        [2 / 32, -2, 1],
                        [4 / 32, -1, 1],
                        [5 / 32, 0, 1],
                        [4 / 32, 1, 1],
                        [2 / 32, 2, 1],
                        [2 / 32, -1, 2],
                        [3 / 32, 0, 2],
                        [2 / 32, 1, 2]
                    ],
                    TwoSierra: [
                        [4 / 16, 1, 0],
                        [3 / 16, 2, 0],
                        [1 / 16, -2, 1],
                        [2 / 16, -1, 1],
                        [3 / 16, 0, 1],
                        [2 / 16, 1, 1],
                        [1 / 16, 2, 1]
                    ]
                };

                if (!kernels[kernel])
                    throw "Unknown dithering kernel: " + kernel;

                var data = getImageData(img),
                    buf32 = data.buf32.slice(0),
                    width = data.width,
                    height = data.height,
                    out32 = new Uint32Array(buf32.length);

                var err_buf = new Float32Array((width + 2) * (height + 2) * 3),
                    buf8_32 = new Uint32Array(new Uint8Array([0,0,0,255]).buffer)[0];

                for (var y = 0; y < height; y++) {
                    var dir = serpentine && y % 2 == 1,
                        x0 = dir ? width - 1 : 0,
                        x1 = dir ? 0 : width - 1,
                        dx = dir ? -1 : 1,
                        idx = y * width + x0;

                    for (var x = x0; x != x1; x += dx, idx += dx) {
                        var i32 = buf32[idx];

                        // image pixel
                        var r = (i32 >>> 0) & 0xff,
                            g = (i32 >>> 8) & 0xff,
                            b = (i32 >>> 16) & 0xff;

                        // apply error diffusion
                        var pos = ((y + 1) * (width + 2) + (x + 1)) * 3;
                        r = Math.max(0, Math.min(255, r + err_buf[pos]));
                        g = Math.max(0, Math.min(255, g + err_buf[pos + 1]));
                        b = Math.max(0, Math.min(255, b + err_buf[pos + 2]));

                        // quantize pixel
                        var i32_cur = (buf8_32 & 0xffffff00) | (r | (g << 8) | (b << 16)),
                            i32_new = this.nearestColor(i32_cur);

                        out32[idx] = i32_new;

                        // calc error
                        var nr = (i32_new >>> 0) & 0xff,
                            ng = (i32_new >>> 8) & 0xff,
                            nb = (i32_new >>> 16) & 0xff;

                        var er = r - nr,
                            eg = g - ng,
                            eb = b - nb;

                        // distribute error
                        var kern = kernels[kernel];
                        for (var i = 0; i < kern.length; i++) {
                            var f = kern[i][0],
                                dx2 = kern[i][1],
                                dy2 = kern[i][2];

                            if (dir) dx2 *= -1;

                            var xpos = x + dx2,
                                ypos = y + dy2;

                            if (xpos >= 0 && xpos < width && ypos >= 0 && ypos < height) {
                                var pos2 = ((ypos + 1) * (width + 2) + (xpos + 1)) * 3;
                                err_buf[pos2] += er * f;
                                err_buf[pos2 + 1] += eg * f;
                                err_buf[pos2 + 2] += eb * f;
                            }
                        }
                    }
                }

                return out32;
            };

            // get reduced palette
            RgbQuant.prototype.palette = function palette(tuples) {
                if (!this.palLocked)
                    this.buildPal();

                if (tuples)
                    return this.idxrgb.slice(0);

                var len = this.idxrgb.length,
                    out = new Uint8Array(len * 4);

                for (var i = 0; i < len; i++) {
                    var pos = i * 4,
                        rgb = this.idxrgb[i];

                    out[pos] = rgb[0];
                    out[pos + 1] = rgb[1];
                    out[pos + 2] = rgb[2];
                    out[pos + 3] = 255;
                }

                return out;
            };

            RgbQuant.prototype.nearestColor = function nearestColor(i32) {
                var idx = this.i32idx[i32];

                if (idx != null)
                    return this.idxi32[idx];

                var r = (i32 >>> 0) & 0xff,
                    g = (i32 >>> 8) & 0xff,
                    b = (i32 >>> 16) & 0xff,
                    minDist = Infinity,
                    minIdx = 0;

                for (var i = 0; i < this.idxrgb.length; i++) {
                    var rgb = this.idxrgb[i],
                        dist = this.colorDist(rgb, [r, g, b]);

                    if (dist < minDist) {
                        minDist = dist;
                        minIdx = i;
                    }
                }

                var i32_ret = this.idxi32[minIdx];

                // cache result
                if (this.useCache) {
                    this.i32idx[i32] = minIdx;
                }

                return i32_ret;
            };

            // builds palette
            RgbQuant.prototype.buildPal = function buildPal() {
                var histogram = this.histogram,
                    sorted = sortedHashKeys(histogram),
                    histlen = sorted.length,
                    uniqueCols = 0,
                    total = 0;

                for (var i = 0; i < histlen; i++) {
                    var i32 = +sorted[i],
                        count = histogram[i32];

                    uniqueCols++;
                    total += count;
                }

                if (uniqueCols <= this.colors) {
                    this.palLocked = true;
                    this.palReduced = false;

                    this.idxrgb = [];
                    this.idxi32 = [];
                    this.i32idx = {};

                    var self = this;
                    sorted.forEach(function(i32, idx) {
                        i32 = +i32;
                        var r = (i32 >>> 0) & 0xff,
                            g = (i32 >>> 8) & 0xff,
                            b = (i32 >>> 16) & 0xff;

                        self.idxrgb[idx] = [r, g, b];
                        self.idxi32[idx] = i32;
                        self.i32idx[i32] = idx;
                    });

                    return;
                }

                this.palLocked = true;
                this.palReduced = true;

                // reduce histogram to initColors
                var reduced = reduceHist(histogram, this.initColors);

                // reduce further to target colors
                if (this.method == 1) {
                    var palette = this.buildPal1D(reduced);
                }
                else if (this.method == 2) {
                    var palette = this.buildPal2D(reduced);
                }

                // set up final palette and lookups
                this.idxrgb = [];
                this.idxi32 = [];
                this.i32idx = {};

                var self = this;
                palette.forEach(function(rgb, idx) {
                    var i32 = (
                        (255    << 24) |	// alpha
                        (rgb[2] << 16) |	// blue
                        (rgb[1] <<  8) |	// green
                         rgb[0]				// red
                    ) >>> 0;

                    self.idxrgb[idx] = rgb;
                    self.idxi32[idx] = i32;
                    self.i32idx[i32] = idx;
                });
            };

            // global top-population method
            RgbQuant.prototype.buildPal1D = function buildPal1D(histogram) {
                var sorted = sortedHashKeys(histogram, true),
                    colors = [],
                    len = Math.min(sorted.length, this.colors);

                for (var i = 0; i < len; i++) {
                    var i32 = +sorted[i];

                    var r = (i32 >>> 0) & 0xff,
                        g = (i32 >>> 8) & 0xff,
                        b = (i32 >>> 16) & 0xff;

                    colors.push([r, g, b]);
                }

                return colors;
            };

            // median cut method
            RgbQuant.prototype.buildPal2D = function buildPal2D(histogram) {
                var sorted = sortedHashKeys(histogram, true);

                var colors = [],
                    boxes = [{colors: sorted, level: 0}];

                while (colors.length < this.colors) {
                    var box = boxes.shift();

                    if (!box) break;

                    if (box.colors.length == 1) {
                        var i32 = +box.colors[0];
                        var r = (i32 >>> 0) & 0xff,
                            g = (i32 >>> 8) & 0xff,
                            b = (i32 >>> 16) & 0xff;

                        colors.push([r, g, b]);
                        continue;
                    }

                    var ranges = getColorRanges(box.colors);
                    var max_range = Math.max(ranges.r, ranges.g, ranges.b);

                    var split_channel = 'r';
                    if (ranges.g == max_range) split_channel = 'g';
                    if (ranges.b == max_range) split_channel = 'b';

                    box.colors.sort(function(a, b) {
                        a = +a; b = +b;
                        var ar, ag, ab, br, bg, bb;

                        ar = (a >>> 0) & 0xff;
                        ag = (a >>> 8) & 0xff;
                        ab = (a >>> 16) & 0xff;

                        br = (b >>> 0) & 0xff;
                        bg = (b >>> 8) & 0xff;
                        bb = (b >>> 16) & 0xff;

                        switch (split_channel) {
                            case 'r': return ar - br;
                            case 'g': return ag - bg;
                            case 'b': return ab - bb;
                        }
                    });

                    var median = Math.floor(box.colors.length / 2);
                    var box1 = {colors: box.colors.slice(0, median), level: box.level + 1};
                    var box2 = {colors: box.colors.slice(median), level: box.level + 1};

                    boxes.push(box1);
                    boxes.push(box2);
                    boxes.sort(function(a, b) {
                        return b.colors.length - a.colors.length;
                    });
                }

                // add remaining single colors
                for (var i = 0; i < boxes.length && colors.length < this.colors; i++) {
                    var box = boxes[i];
                    var i32 = +box.colors[0];
                    var r = (i32 >>> 0) & 0xff,
                        g = (i32 >>> 8) & 0xff,
                        b = (i32 >>> 16) & 0xff;

                    colors.push([r, g, b]);
                }

                return colors;
            };

            // builds a color histogram
            RgbQuant.prototype.colorStats1D = function colorStats1D(buf32) {
                var histogram = this.histogram,
                    len = buf32.length;

                for (var i = 0; i < len; i++) {
                    var i32 = buf32[i] & 0x00ffffff;
                    histogram[i32] = (histogram[i32] || 0) + 1;
                }
            };

            // builds a 2d subregion histogram
            RgbQuant.prototype.colorStats2D = function colorStats2D(buf32, width) {
                var histogram = this.histogram,
                    len = buf32.length,
                    boxW = this.boxSize[0],
                    boxH = this.boxSize[1],
                    boxPxls = this.boxPxls,
                    width2 = Math.ceil(width / boxW) * boxW,
                    height = Math.ceil(len / width),
                    height2 = Math.ceil(height / boxH) * boxH;

                for (var y = 0; y < height2; y += boxH) {
                    for (var x = 0; x < width2; x += boxW) {
                        var box = {};

                        for (var y2 = y; y2 < y + boxH && y2 < height; y2++) {
                            for (var x2 = x; x2 < x + boxW && x2 < width; x2++) {
                                var idx = y2 * width + x2;
                                if (idx >= len) continue;

                                var i32 = buf32[idx] & 0x00ffffff;
                                box[i32] = (box[i32] || 0) + 1;
                            }
                        }

                        for (var i32 in box) {
                            if (box[i32] >= boxPxls) {
                                histogram[i32] = (histogram[i32] || 0) + box[i32];
                            }
                        }
                    }
                }
            };

            // helper functions
            function sortedHashKeys(obj, desc) {
                var keys = Object.keys(obj);

                keys.sort(function(a, b) {
                    return desc ? obj[b] - obj[a] : obj[a] - obj[b];
                });

                return keys;
            }

            function getImageData(img, width) {
                var can = document.createElement("canvas"),
                    ctx = can.getContext("2d"),
                    imgData, buf8, buf32;

                if (img instanceof ImageData) {
                    can.width = img.width;
                    can.height = img.height;
                    ctx.putImageData(img, 0, 0);
                    imgData = img;
                }
                else {
                    can.width = img.naturalWidth || img.width;
                    can.height = img.naturalHeight || img.height;
                    
                    if (width && can.width > width) {
                        can.height = can.height * width / can.width;
                        can.width = width;
                    }

                    ctx.drawImage(img, 0, 0, can.width, can.height);
                    imgData = ctx.getImageData(0, 0, can.width, can.height);
                }

                buf8 = new Uint8Array(imgData.data.buffer);
                buf32 = new Uint32Array(imgData.data.buffer);

                return {
                    buf8: buf8,
                    buf32: buf32,
                    data: imgData.data,
                    width: imgData.width || can.width,
                    height: imgData.height || can.height
                };
            }

            function getColorRanges(colors) {
                var min_r = 255, max_r = 0,
                    min_g = 255, max_g = 0,
                    min_b = 255, max_b = 0;

                for (var i = 0; i < colors.length; i++) {
                    var i32 = +colors[i];
                    var r = (i32 >>> 0) & 0xff,
                        g = (i32 >>> 8) & 0xff,
                        b = (i32 >>> 16) & 0xff;

                    if (r < min_r) min_r = r;
                    if (r > max_r) max_r = r;
                    if (g < min_g) min_g = g;
                    if (g > max_g) max_g = g;
                    if (b < min_b) min_b = b;
                    if (b > max_b) max_b = b;
                }

                return {
                    r: max_r - min_r,
                    g: max_g - min_g,
                    b: max_b - min_b
                };
            }

            function reduceHist(histogram, colors) {
                var sorted = sortedHashKeys(histogram, true),
                    len = Math.min(sorted.length, colors),
                    reduced = {};

                for (var i = 0; i < len; i++) {
                    var i32 = +sorted[i];
                    reduced[i32] = histogram[i32];
                }

                return reduced;
            }

            function distEuclidean(a, b) {
                var dr = a[0] - b[0],
                    dg = a[1] - b[1],
                    db = a[2] - b[2];

                return Math.sqrt(dr * dr + dg * dg + db * db);
            }

            function distManhattan(a, b) {
                return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]) + Math.abs(a[2] - b[2]);
            }

            // export
            if (typeof module !== 'undefined' && module.exports) {
                module.exports = RgbQuant;
            } else {
                window.RgbQuant = RgbQuant;
            }
        })();
    </script>

    <!-- Bilateral Filter Implementation -->
    <script>
        // Bilateral Filter for edge-preserving smoothing
        function bilateralFilter(imageData, sigmaSpace, sigmaColor) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const result = new Uint8ClampedArray(data.length);
            
            // Limit kernel size for performance and quality
            const kernelSize = Math.min(Math.ceil(sigmaSpace * 2) + 1, 15);
            const halfKernel = Math.floor(kernelSize / 2);
            
            // Pre-compute spatial weights
            const spatialWeights = [];
            for (let dy = -halfKernel; dy <= halfKernel; dy++) {
                spatialWeights[dy + halfKernel] = [];
                for (let dx = -halfKernel; dx <= halfKernel; dx++) {
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    spatialWeights[dy + halfKernel][dx + halfKernel] = 
                        Math.exp(-(distance * distance) / (2 * sigmaSpace * sigmaSpace));
                }
            }
            
            // Process each pixel
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const centerIdx = (y * width + x) * 4;
                    const centerR = data[centerIdx];
                    const centerG = data[centerIdx + 1];
                    const centerB = data[centerIdx + 2];
                    const centerA = data[centerIdx + 3];
                    
                    let sumR = 0, sumG = 0, sumB = 0;
                    let weightSum = 0;
                    
                    // Apply bilateral filter kernel
                    for (let dy = -halfKernel; dy <= halfKernel; dy++) {
                        for (let dx = -halfKernel; dx <= halfKernel; dx++) {
                            const ny = y + dy;
                            const nx = x + dx;
                            
                            // Check bounds
                            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                const neighborIdx = (ny * width + nx) * 4;
                                const neighborR = data[neighborIdx];
                                const neighborG = data[neighborIdx + 1];
                                const neighborB = data[neighborIdx + 2];
                                
                                // Calculate color distance (normalized to 0-1)
                                const colorDist = Math.sqrt(
                                    Math.pow((centerR - neighborR) / 255, 2) +
                                    Math.pow((centerG - neighborG) / 255, 2) +
                                    Math.pow((centerB - neighborB) / 255, 2)
                                );
                                
                                // Calculate color weight
                                const colorWeight = Math.exp(-(colorDist * colorDist) / (2 * (sigmaColor / 255) * (sigmaColor / 255)));
                                
                                // Combined weight
                                const weight = spatialWeights[dy + halfKernel][dx + halfKernel] * colorWeight;
                                
                                sumR += neighborR * weight;
                                sumG += neighborG * weight;
                                sumB += neighborB * weight;
                                weightSum += weight;
                            }
                        }
                    }
                    
                    // Normalize and set result
                    if (weightSum > 0) {
                        result[centerIdx] = Math.round(Math.max(0, Math.min(255, sumR / weightSum)));
                        result[centerIdx + 1] = Math.round(Math.max(0, Math.min(255, sumG / weightSum)));
                        result[centerIdx + 2] = Math.round(Math.max(0, Math.min(255, sumB / weightSum)));
                        result[centerIdx + 3] = centerA; // Preserve alpha
                    } else {
                        // Fallback to original pixel
                        result[centerIdx] = centerR;
                        result[centerIdx + 1] = centerG;
                        result[centerIdx + 2] = centerB;
                        result[centerIdx + 3] = centerA;
                    }
                }
            }
            
            return new ImageData(result, width, height);
        }
    </script>

    <!-- Application JavaScript -->
    <script>
        class ImageQuantizationApp {
            constructor() {
                this.currentImage = null;
                this.quantizerOriginal = null;
                this.quantizerFiltered = null;
                this.quantizedOriginalImageData = null;
                this.quantizedFilteredImageData = null;
                
                this.initializeElements();
                this.bindEvents();
            }

            initializeElements() {
                this.uploadSection = document.getElementById('uploadSection');
                this.uploadButton = document.getElementById('uploadButton');
                this.fileInput = document.getElementById('fileInput');
                this.processButton = document.getElementById('processButton');
                this.statusDiv = document.getElementById('status');
                this.imagesContainer = document.getElementById('imagesContainer');
                this.originalImage = document.getElementById('originalImage');
                this.filteredCanvas = document.getElementById('filteredImage');
                this.quantizedOriginalCanvas = document.getElementById('quantizedOriginal');
                this.quantizedFilteredCanvas = document.getElementById('quantizedFiltered');
                this.paletteSection = document.getElementById('paletteSection');
                this.paletteCanvas = document.getElementById('paletteCanvas');
                
                // Download buttons for original quantized image
                this.downloadOriginalPng = document.getElementById('downloadOriginalPng');
                this.downloadOriginalJpg = document.getElementById('downloadOriginalJpg');
                
                // Download buttons for filtered quantized image
                this.downloadFilteredPng = document.getElementById('downloadFilteredPng');
                this.downloadFilteredJpg = document.getElementById('downloadFilteredJpg');

                // Controls
                this.sigmaSpaceInput = document.getElementById('sigmaSpace');
                this.sigmaColorInput = document.getElementById('sigmaColor');
                this.colorsInput = document.getElementById('colors');
                this.methodSelect = document.getElementById('method');
                this.dithKernSelect = document.getElementById('dithKern');
                this.initColorsInput = document.getElementById('initColors');
            }

            bindEvents() {
                // File input handling
                this.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                
                // Upload button click
                this.uploadButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent event bubbling to upload section
                    this.fileInput.click();
                });
                
                // Drag and drop on upload section
                this.uploadSection.addEventListener('dragover', (e) => this.handleDragOver(e));
                this.uploadSection.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                this.uploadSection.addEventListener('drop', (e) => this.handleDrop(e));
                
                // Click on upload section (but not on button)
                this.uploadSection.addEventListener('click', (e) => {
                    // Only trigger if click is not on the button
                    if (e.target !== this.uploadButton) {
                        this.fileInput.click();
                    }
                });

                // Process button
                this.processButton.addEventListener('click', () => this.processImage());

                // Download buttons for original quantized image
                this.downloadOriginalPng.addEventListener('click', () => this.downloadImage('png', 'original'));
                this.downloadOriginalJpg.addEventListener('click', () => this.downloadImage('jpeg', 'original'));
                
                // Download buttons for filtered quantized image
                this.downloadFilteredPng.addEventListener('click', () => this.downloadImage('png', 'filtered'));
                this.downloadFilteredJpg.addEventListener('click', () => this.downloadImage('jpeg', 'filtered'));
            }

            handleDragOver(e) {
                e.preventDefault();
                this.uploadSection.classList.add('dragover');
            }

            handleDragLeave(e) {
                e.preventDefault();
                this.uploadSection.classList.remove('dragover');
            }

            handleDrop(e) {
                e.preventDefault();
                this.uploadSection.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.loadImage(files[0]);
                }
            }

            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.loadImage(file);
                }
            }

            loadImage(file) {
                // Validate file type
                if (!file.type.startsWith('image/')) {
                    this.showStatus('Please select a valid image file.', 'error');
                    return;
                }

                // Validate file size (max 10MB)
                if (file.size > 10 * 1024 * 1024) {
                    this.showStatus('Image file is too large. Please select an image smaller than 10MB.', 'error');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.currentImage = img;
                        this.originalImage.src = img.src;
                        this.processButton.disabled = false;
                        this.showStatus('Image loaded successfully! You can now process it.', 'success');
                        this.imagesContainer.style.display = 'grid';
                        
                        // Reset previous results
                        this.filteredCanvas.width = 0;
                        this.filteredCanvas.height = 0;
                        this.quantizedOriginalCanvas.width = 0;
                        this.quantizedOriginalCanvas.height = 0;
                        this.quantizedFilteredCanvas.width = 0;
                        this.quantizedFilteredCanvas.height = 0;
                        this.paletteSection.style.display = 'none';
                        
                        // Disable all download buttons
                        this.downloadOriginalPng.disabled = true;
                        this.downloadOriginalJpg.disabled = true;
                        this.downloadFilteredPng.disabled = true;
                        this.downloadFilteredJpg.disabled = true;
                    };
                    img.onerror = () => {
                        this.showStatus('Failed to load the image. Please try a different file.', 'error');
                    };
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    this.showStatus('Failed to read the file. Please try again.', 'error');
                };
                reader.readAsDataURL(file);
            }

            processImage() {
                if (!this.currentImage) {
                    this.showStatus('Please select an image first.', 'error');
                    return;
                }

                this.showStatus('Step 1/4: Applying bilateral filter...', 'processing');
                this.processButton.disabled = true;

                // Use setTimeout to allow UI to update before heavy computation
                setTimeout(() => {
                    try {
                        // Step 1: Apply bilateral filter and get original ImageData
                        const originalImageData = this.getOriginalImageData();
                        const filteredImageData = this.applyBilateralFilter(originalImageData);
                        
                        this.showStatus('Step 2/4: Building color palette from original image...', 'processing');
                        
                        // Step 2: Create quantizer using the original image
                        setTimeout(() => {
                            try {
                                const opts = {
                                    colors: parseInt(this.colorsInput.value),
                                    method: parseInt(this.methodSelect.value),
                                    initColors: parseInt(this.initColorsInput.value),
                                    dithKern: this.dithKernSelect.value || null,
                                    dithSerp: false
                                };

                                this.quantizerOriginal = new RgbQuant(opts);
                                this.quantizerFiltered = new RgbQuant(opts);

                                // Sample both images to build consistent palettes
                                this.quantizerOriginal.sample(originalImageData);
                                this.quantizerFiltered.sample(filteredImageData);

                                this.showStatus('Step 3/4: Quantizing original image...', 'processing');
                                
                                // Step 3: Quantize the original image
                                setTimeout(() => {
                                    try {
                                        // Quantize original image
                                        const originalPaletteData = this.quantizerOriginal.palette();
                                        const quantizedOriginalData = this.quantizerOriginal.reduce(originalImageData);

                                        this.showStatus('Step 4/4: Quantizing filtered image...', 'processing');
                                        
                                        // Step 4: Quantize the filtered image
                                        setTimeout(() => {
                                            try {
                                                // Quantize filtered image
                                                const filteredPaletteData = this.quantizerFiltered.palette();
                                                const quantizedFilteredData = this.quantizerFiltered.reduce(filteredImageData);

                                                // Display results
                                                this.displayQuantizedImage(quantizedOriginalData, originalImageData.width, originalImageData.height, 'original');
                                                this.displayQuantizedImage(quantizedFilteredData, filteredImageData.width, filteredImageData.height, 'filtered');
                                                this.displayPalette(originalPaletteData);

                                                this.showStatus(`Processing complete! Quantized both original and filtered images to ${opts.colors} colors.`, 'success');
                                                
                                                // Enable download buttons
                                                this.downloadOriginalPng.disabled = false;
                                                this.downloadOriginalJpg.disabled = false;
                                                this.downloadFilteredPng.disabled = false;
                                                this.downloadFilteredJpg.disabled = false;

                                            } catch (error) {
                                                console.error('Filtered quantization error:', error);
                                                this.showStatus('Error during filtered image quantization: ' + error.message, 'error');
                                            } finally {
                                                this.processButton.disabled = false;
                                            }
                                        }, 100);

                                    } catch (error) {
                                        console.error('Original quantization error:', error);
                                        this.showStatus('Error during original image quantization: ' + error.message, 'error');
                                        this.processButton.disabled = false;
                                    }
                                }, 100);

                            } catch (error) {
                                console.error('Palette error:', error);
                                this.showStatus('Error building palette: ' + error.message, 'error');
                                this.processButton.disabled = false;
                            }
                        }, 100);

                    } catch (error) {
                        console.error('Bilateral filter error:', error);
                        this.showStatus('Error applying bilateral filter: ' + error.message, 'error');
                        this.processButton.disabled = false;
                    }
                }, 100);
            }

            getOriginalImageData() {
                // Get image data from original image
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = this.currentImage.width;
                canvas.height = this.currentImage.height;
                ctx.drawImage(this.currentImage, 0, 0);
                
                return ctx.getImageData(0, 0, canvas.width, canvas.height);
            }

            applyBilateralFilter(originalImageData) {
                // Apply bilateral filter
                const sigmaSpace = parseFloat(this.sigmaSpaceInput.value);
                const sigmaColor = parseFloat(this.sigmaColorInput.value);
                const filteredImageData = bilateralFilter(originalImageData, sigmaSpace, sigmaColor);
                
                // Display filtered image
                this.displayFilteredImage(filteredImageData);
                
                return filteredImageData;
            }

            displayFilteredImage(imageData) {
                const canvas = this.filteredCanvas;
                const ctx = canvas.getContext('2d');

                canvas.width = imageData.width;
                canvas.height = imageData.height;

                ctx.putImageData(imageData, 0, 0);
            }

            displayQuantizedImage(imageData, width, height, type) {
                const canvas = type === 'original' ? this.quantizedOriginalCanvas : this.quantizedFilteredCanvas;
                const ctx = canvas.getContext('2d');

                canvas.width = width;
                canvas.height = height;

                const imgData = ctx.createImageData(width, height);
                imgData.data.set(imageData);
                ctx.putImageData(imgData, 0, 0);

                // Store the image data for download
                if (type === 'original') {
                    this.quantizedOriginalImageData = imgData;
                } else {
                    this.quantizedFilteredImageData = imgData;
                }
            }

            displayPalette(paletteData) {
                const canvas = this.paletteCanvas;
                const ctx = canvas.getContext('2d');

                const colors = paletteData.length / 4;
                const swatchSize = 32;
                const swatchesPerRow = Math.ceil(Math.sqrt(colors));
                const rows = Math.ceil(colors / swatchesPerRow);

                canvas.width = swatchesPerRow * swatchSize;
                canvas.height = rows * swatchSize;

                for (let i = 0; i < colors; i++) {
                    const row = Math.floor(i / swatchesPerRow);
                    const col = i % swatchesPerRow;
                    
                    const r = paletteData[i * 4];
                    const g = paletteData[i * 4 + 1];
                    const b = paletteData[i * 4 + 2];

                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(col * swatchSize, row * swatchSize, swatchSize, swatchSize);

                    // Add border
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(col * swatchSize, row * swatchSize, swatchSize, swatchSize);
                }

                this.paletteSection.style.display = 'block';
            }

            downloadImage(format, type) {
                const imageData = type === 'original' ? this.quantizedOriginalImageData : this.quantizedFilteredImageData;
                
                if (!imageData) {
                    this.showStatus(`No processed ${type} image to download.`, 'error');
                    return;
                }

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = imageData.width;
                canvas.height = imageData.height;
                ctx.putImageData(imageData, 0, 0);

                const mimeType = format === 'png' ? 'image/png' : 'image/jpeg';
                const quality = format === 'jpeg' ? 0.9 : undefined;

                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `quantized-${type}-image.${format}`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    this.showStatus(`${type.charAt(0).toUpperCase() + type.slice(1)} image downloaded as ${format.toUpperCase()}.`, 'success');
                }, mimeType, quality);
            }

            showStatus(message, type) {
                this.statusDiv.innerHTML = '';
                this.statusDiv.className = `status ${type}`;

                if (type === 'processing') {
                    const loader = document.createElement('span');
                    loader.className = 'loading';
                    this.statusDiv.appendChild(loader);
                }

                const text = document.createElement('span');
                text.textContent = message;
                this.statusDiv.appendChild(text);
            }
        }

        // Initialize the app when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new ImageQuantizationApp();
        });
    </script>
</body>
</html>
